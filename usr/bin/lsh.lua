---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by torvald.
--- DateTime: 2019-11-03 02:02
---

local args = {...}

local is_superuser = true -- single user mode!
local current_user = "root"

local prompt = is_superuser and "#" or "$"
local shell_currentDir = {"test", "purpose", "dirs"}

--- environmental varaibles
env = {}
env.PWD = "/" .. table.concat(shell_currentDir, "/")
--- end of environmental variables

local function printPrompt()
    io.write("root:"..env.PWD..prompt.." ")
end

local internal_commands = {}
internal_commands.cd = function(args)
    for i, v in ipairs(shell_currentDir) do
        print(i, v)
    end
end

require("etc/motd")

--- parse input into args[], where:
--- input: tar -xvf out "file1 file2" file3
--- t[1] = tar'
--- t[2] = -xvf'
--- t[3] = out'
--- t[4] = file1 file2'
--- t[5] = file3'     (' indicates string end)
local function parse_user_input(s)
    local t = {}
    local sb = "" -- string buffer

    function dispatch_sb()
        if sb:len() > 0 then
            table.insert(t, sb)
            sb = ""
        end
    end

    -- null string
    if s:len() == 0 then return nil end
    -- trim indents
    if s:byte() == 32 then
        k = 2 while s:byte(k) == 32 do k = k + 1 end
        s = s:sub(k)
    end
    -- trim extra spaces
    if s:byte(s:len()) == 32 then
        k = s:len() - 1 while s:byte(k) == 32 do k = k - 1 end
        s = s:sub(1, k)
    end

    -- states
    local quotation_mode -- nil, '(0x22), "(0x27)
    local escape_mode = false
    for i = 1, s:len() do
        local v = s:byte(i)

        if i == s:len() then
            if v ~= quotation_mode then
                sb = sb .. string.char(v)
            end
            dispatch_sb()
        elseif quotation_mode then
            if v == quotation_mode then
                quotation_mode = nil
                dispatch_sb()
            else
                sb = sb .. string.char(v)
            end
        elseif not quotation_mode and (v == 0x22 or v == 0x27) then
            quotation_mode = v
        elseif not quotation_mode and v == 0x20 then
            dispatch_sb()
        else
            sb = sb .. string.char(v)
        end
    end

    return t
end

--- example input: lsh path/to/script.lua args1 args2
------ t[1] = lsh'
------ t[2] = path/to/script.lua'
------ t[3] = args1'
------ t[4] = args2'            (' indicates string end)invoke = function(args)
_lix_invoke = function(args)
    local bin_name = args[1] -- call name with .lua extension attached
    local _t_args = {} -- call arguments
    for i = 2, #args do _t_args[i - 1] = args[i] end
    local call_args = unpack(_t_args)

    if (bin_name:lower():sub(-4) ~= ".lua") then bin_name = bin_name .. ".lua" end

    -- iterate thru LIX_PATH
    local internal_f = internal_commands[args[1]]
    local invoke_status
    local invoke_f
    if type(internal_f) == "function" then
        invoke_status, invoke_f = pcall(function() internal_f(call_args) end)
    else
        for i = 1, #LIX_PATH do
            local p = LIX_PATH[i]
            invoke_status, invoke_f = pcall(function()
                local t = loadfile(p .. bin_name)
                if t then
                    t(call_args)
                else
                    error(bin_name..": command not found")
                end
            end)

            if invoke_status then break end
        end
    end

    -- print "no such file or whatever" message
    if not invoke_status then print("error: "..invoke_f) end
end
--- end of Application Stub

print(motd[1])

while true do
    printPrompt()
    local user_input = parse_user_input(io.read())
    if user_input then
        --print("debug print;") for i, v in ipairs(user_input) do print(i, v) end
        _lix_invoke(user_input)
    end

end
